---
layout: post
title: 프로세스, 스레드는 어떻게 통신할까 그리고 어떤 문제가 발생할 수 있을까? (OS-3)
description: >
  멀티 프로세스, 멀티 스레드는 어떻게 통신할까? 그리고 어떤 문제들이 발생할 수 있을까?
sitemap: false
hide_last_modified: true
---

---

## 멀티 프로세스는 각자 어떻게 통신할까? -> IPC
- 프로세스는 독립적인 주소공간을 갖기 때문에 서로 메모리를 공유하지 않음
- 운영체제는 프로세스 간 자원 접근을 위해 IPC(Inter Process Communication) 제공

## ⭐️⭐️⭐️[IPC](https://jwprogramming.tistory.com/54)
1. 공유 메모리 방식
  - 주소공간 일부를 공유
  - 모든 참여하는 프로세스에게 보이며, 하나의 프로세스가 공유 메모리에 쓴 데이터는 다른 프로세스에서 그대로 읽을 수 있음
  - 커널이 맨 처음 한번만 할당해주고 그 이후로는 관여안해서 속도가 빠름
  - 동시에 같은 메모리 위치에 접근하게 되면 일관성 문제가 발생할 수 있음 -> **세마포어, 뮤텍스**같은 동기화 도구를 사용하여 조절

2. 메세지 전달 방식
  - 커널이(system call - send, receive 연산) 관리하기 때문에 느리지만 안정성이 높음
  - 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는 데 유용
  - 구현하기 쉬움
  - 대표적인 예 : pipe, socket, message queue

## 멀티 스레드는 어떻게 통신할까? 
- 메모리 공간을 공유하므로 멀티 프로세스보다 매우 빠르게 통신
- Heap 공간을 공유로 통신
- 동시성 문제에 취약

## 멀티 프로세스/스레드는 어떤 문제가 발생할 수 있을까?
  1. **동기화 문제**
  - 서로 다른 스레드가 동일한 자원에 동시에 접근하여 발생
  - 이를 해결하기 위해 세마포어와 뮤텍스 방법이 사용됨
  - entry section -> critical section -> exit section 순으로 실행

  ❗️뮤텍스(≅이진 세마포어)
  - mutual exclusion
  - 공유자원에 접근할 수 있는 프로세스/스레드 개수 1개
  - critical section에 들어갈 때 mutex lock을 획득하고 exit 영역으로 갈때 mutex lock을 반환함 
  - mutex lock은 entry section에서 받고(=entry sections에서 잠가버리고) 받으면 바로 critical section실행
  - busy waiting 문제 발생
    1. 프로세스/스레드가 mutex lock을 받으려고 시도 -> 근데 이미 다른애가 쓰고 있어서 못받음
    2. 기다려야 함 -> 프로세스/스레드가 mutex 상태가 어떤지 계속 대기하는 방식(계속 cpu 연산을 함) -> 불필요한 cpu 연산이 실행됨

 ❗️세마포어
  - 공유자원에 접근할 수 있는 프로세스/스레드 개수 2개 이상
  - 세마포 변수 S 만큼 동시 접근 가능
  - S>0이면 critical section에 들어가고 S를 하나 줄인다.
  - S==0이면 다른 프로세스/스레드는 critical section에 들어갈 수 없다.(==busy waiting)
  - exit section에 들어가면 다시 S를 하나 늘린다.

  2. **DeadLock**
  - 둘 이상의 프로세스/스레드가 서로 점유하고 있는 자원을 서로 기다리는데, **무한 대기에 빠지는 상황**
  - 다음 4가지 조건을 **동시에 다** 만족해야 발생함
    1. 상호 배제(mutual exclusion) : 한번에 하나의 프로세스/스레드만 자원을 사용할 수 있는 상황
    2. 점유 대기(hold and wait) : 이미 자원을 할당 받았음에도, 다른 프로세스/스레드가 보유한 자원을 추가 요청하며 대기하는 상황
    3. 비선점(no preemption) : 다른 프로세스/스레드가 점유하고 있는 자원을 뺏을 수 없는 상황
    4. 순환 대기(circular wait) : 프로세스(스레드)A는 B가 갖고있는 자원이 필요하고 B는 C꺼가 필요하고 C는 A꺼가 필요한 상황
  - 예시
  ![image](https://github.com/inh2613/inh2613.github.io/assets/62206617/701b8ab1-b44e-44b1-ae98-4c4f47f4f59b)
 
  - [해결 방법](https://kukuta.tistory.com/281)
    1. 무시 : 애초에 데드락이 발생할 상황이 적다는 가정하에 데드락 발생해도 무시해버림, 현대에서 많이 사용(현대 시스템에서 데드락 잘안일어나서)
    2. 예방 : 앞선 4가지 조건 중 하나가 성립하지 않게 함, 보통 순환 대기 조건을 막는 방법이 현실적임, 효율성 별로/비용 큼
    3. 회피 : [은행원 알고리즘](https://jhnyang.tistory.com/102), [자원할당 그래프 알고리즘](https://vansoft1215.tistory.com/177)을 이용해 자원을 할당함
    4. 탐지-회복 : 시스템 검사를 통해 탐지하고 회복함, 효율성 별로/비용 큼

  ## 용어 정리
  - 원자 연산 : 연산이 시작되면 중단되거나 다른 연산과 중첩되지 않고 완료되는 연산
  - 임계 영역 : 둘 이상의 프로세스/스레드가 동시에 동일한 자원에 접근하도록 하는 프로그램 코드 부분, 원자적으로 실행되어야 함

  🤔 다음 시간에는 메모리 관리 기법에 대해 자세히 알아보자!
  